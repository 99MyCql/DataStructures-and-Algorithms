# 二分

## 模板

1. 查找序列中第一个满足条件的值，将区间`[l, r]`划分为`[l, mid]`和`[mid+1, r]`，边界值`mid`在左区间：

    ```c++
    int l = 0, r = n-1;
    while (l < r) {
        int mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l; // check(l) == false 说明没找到
    ```

2. 查找序列中最后一个满足条件的值，将区间`[l, r]`划分为`[l, mid-1]`和`[mid, r]`，边界值`mid`在右区间：

    ```c++
    int l = 0, r = n-1;
    while (l < r) {
        int mid = (l + r + 1) / 2; // 需要+1，不然当 r=l+1 时，mid永远等于l，若同时 check(mid)==true 会死循环
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
    ```

3. 查找序列中唯一满足条件的值，将区间划分为`[l, mid-1]`、`mid`、`[mid+1, r]`：

    ```c++
    int l = 0, r = n-1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (A[mid] == target) return mid;
        if (A[mid] > target) r = mid-1;
        else l = mid+1;
    }
    return -1;
    ```

## 案例

### 对于非递减数组A，寻找第一个大于或等于target的值的下标

采用模板1，区间被划分为`[l, mid]`和`[mid+1, r]`。若`A[mid] < target`，说明左区间`[l, mid]`都小于目标值，直接选择右区间。若`A[mid] >= target`，说明右区间`[mid+1, r]`的值都大于等于目标值，左区间`[l, mid]`至少存在一个值大于等于目标值，选择左区间。最终`l=r`，会找到第一个大于或等于目标值的值。

```c++
int l = 0, r = n-1;
while (l < r) {
    int mid = (l + r) / 2;
    if (A[mid] >= target) r = mid;
    else l = mid + 1;
}
return l; // 若A[l]!=target，则说明没找到
```

同理，可以找到第一个大于目标值的值的下标。

### 对于非递减数组A，寻找最后一个小于或等于target的值的下标

采用模板2，区间被划分成`[l, mid-1]`和`[mid, r]`。若`A[mid] <= target`，说明mid左边都小于等于，选择右区间`[mid, r]`，最终会找到最后一个小于等于目标值的值：

```c++
while (l < r) {
    int mid = (l + r + 1) / 2;
    if (A[mid] <= target) l = mid;
    else r = mid - 1;
}
return l;
```

为什么不用模板1而使用模板2？因为，模板1中**满足条件的边界值mid在左区间**，那么只适合找第1个，而模板2边界值mid在右区间，适合找最后一个。
