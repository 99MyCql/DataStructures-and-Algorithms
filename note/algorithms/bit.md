# bit

## lowbit 求最低位的1所对应的值

```c
x & (-x)
```

## Brian Kernighan 将二进制表示的最后一个1变成0

```c
x & (x−1)
```

## 异或

位的值相同得0，不同得1。

满足：

- 交换律：a ^ b = b ^ a
- 结合律：a ^b ^ c = a ^ (b ^ c) = (a ^ b) ^ c

## 用二进制位表示子集

一个长度为n的集合有2^n个子集。

用一个n位的比特序列表示长度为n的子集，每一位上，1表示取集合中对应位置的数，0则不取。

假设n=3，000~111则可以表示所有的子集。

## 不用加减乘除做加法

以5+7=12为例，先参考十进制是怎么做的：

1. 相加各位的值，不算进位，得到2。
2. 计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。
3. 重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。

同理，二进制(101)+(111)相加也可以分为三步：

1. 相加各位的值，这一步用异或实现：(101)^(111)=(010)。
2. 计算进位值，用或+左移实现：((101)&(111)) << 1 = (1010)，如果这一步得到的值为0，那么第1步就是最终结果。
3. 重复上述两步，只是相加的值变成(010)和(1010)。

```c
int add(int a, int b) {
    int sum = a^b, c; // sum = a^b 防止 b 为 0
    while (b != 0) {
        sum = a ^ b;
        c = (a & b) << 1;
        a = sum;
        b = c;
    }
    return sum;
}
```
