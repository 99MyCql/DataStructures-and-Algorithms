# leetcode 刷题记录

[TOC]

## 前言

简单题记录较少，多为中等与困难题。

部分经典题型的详细解法在 `study` 笔记中。

## 19 - 删除链表的倒数第N个结点 - 中等 - C++

双指针。

两个指针，第一个指针从头到尾遍历链表，当遍历到第`N+1`个结点时，第二个指针从第`1`个结点开始遍历。此后，两个指针同步前进，相隔保持`N`个结点。直到第一个指针到达最后一个`NULL`结点，两个指针停止，此时第二个指针指向倒数第`N`个结点。

## 20 - 有效括号 - 简单 - C++

栈的简单应用。

## 23 - 合并K个排序链表 - 困难 - C++

多种解法，较优的方法有：归并、优先队列。

## 31 - 下一个排列 - 中等 - C++

[字典序算法](https://blog.csdn.net/happyrocking/article/details/83619392)。

## 33 - 搜索旋转排序数组 - 中等 - GO

分治。

升序数组在某点旋转后，会变成两段升序子数组，由于升序子数组依旧具有升序特性，所以可以使用二分法求解，即分治算法。

只是在二分的时候，需要更复杂的条件判断。

同时，二分法需要注意边界问题：

```go
if target < nums[mid] {
    search(nums[:mid], target) // 切片 [:mid] 不包括 mid
}

if target >= nums[mid] {
    search(nums[mid:], target)
}
```

## 52 - N皇后II - 困难 - C++

栈 / 递归。

此题用递归回溯的方法更加容易，但也可以用栈的方法实现。

## 53 - 最大子序和 - 简单 - GO

贪心。

每走一步，都计算出最优解。

## 64 - 最小路径和 - 中等 - C++

简单动态规划。

## 78 - 子集 - 中等 - Go

简单的排列组合问题，递归解决即可。

对于`[1,2,3]`，3个中取2个组合，即：

- 将1加入，对`[2,3]`2个中取1个组合所产生的各个集合`[[2],[3]]`中，变成`[[1,2],[1,3]]`；
- 将2加入，对`[3]`1个取1个组合所产生的各个集合`[[3]]`中，变成`[[2,3]]`；
- ~~将3加入，对`[]`0个取1个组合所产生的各个集合`[[]]`中~~ 由于`[]`为空，不能进入组合；
- 最终，合并为`[[1,2],[1,3],[2,3]]`

由上述示例可知，构造一个函数（类似于$C_b^a$）：从`b`中取`a`个组合，并返回对应集合。然后，递归调用该函数即可。

## 84 - 柱状图中的最大矩形 - 困难 - C++

解法有很多种，我使用了两种解法：

- 暴力解法：`0 <= i < n` 进行遍历，对于每次的 `i` ，再使 `i < j < n` 进行遍历。`j` 遍历过程中，记录 `i ~ j` 区间内柱子高度的最小值 `min` ，并计算矩形面积 `(j - i) * min`。最后，从所有矩形面积中取最大值。

- 单调栈。

参考：

- [官方题解](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode/)

- [找两边第一个小于它的值](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhao-liang-bian-di-yi-ge-xiao-yu-ta-de-zhi-by-powc/)

## 85 - 最大矩形 - 困难 - C++

解法依旧有很多种，我选择了84题的延申解法，即：将 `0~i` 行看成柱状图，使用84题求柱状图中的最大矩形，`i` 从 `0~n` 遍历，取每一次遍历结果中最大值。

参考：

- [官方题解](https://leetcode-cn.com/problems/maximal-rectangle/solution/zui-da-ju-xing-by-leetcode/)

## 92 - 反转链表II - 中等 - C++

链表头插法。

## 114 - 二叉树展开为链表 - 中等 - C++

递归。

先将左子树和右子树转换成链表，然后将左子树链表连接于根结点右边、右子树链表连接于左子树链表之后。

## 142 - 环形链表II - 中等 - C++

Floyd判圈算法——快慢指针。

## 150 - 逆波兰表达式求值 - 中等 - C++

栈。

操作数栈，遇到运算符就弹出栈顶两个元素进行运算，再将结果压栈。

## 155 - 最小栈 - 简单 - C++

单调栈的简单应用。

## 160 - 相交链表 - 简单 - C++

链表。

先计算出两个链表的长度，然后用指针`long`指向长链表，指针`short`指向短链表。`long`指针先走 长短链表差值 的步数，此时`short`指针再开始与`long`指针同步前进，若途中两个指针相等，则说明链表相交。

## 224 - 基本计算器 - 困难 - C++

栈。

用两个栈（操作数栈和运算符栈）求解表达式。

## 225 - 用队列实现栈 - C++ - 简单

队列。

两个队列。入栈时，将元素压入其中一个不为空的队列；出栈时，将 `n-1` 个元素从不为空的队列中弹出，并压入另一个空队列中，最后弹出剩下的第 `n` 个元素，即栈顶元素；通过一个 `top` 变量记录栈顶元素，获取栈顶元素时，直接返回 `top` 变量。

## 232 - 用栈实现队列 - 简单 - C++

栈。

一个栈A，一个栈B。入队时，将元素压入栈A；出队时，将元素从栈B中弹出。如果栈B为空，则将栈A中元素依次弹出、压入栈B。

## 239 - 滑动窗口的最大值 - C++ - 困难

双向队列 + 单调队列。

由于窗口是滑动的，所以某次窗口内的最大值，最终会被抛弃在窗口之外，此时就需要扶持原本的第二大值上位了。

那么如何快速地找到第二大值呢？我们可能会想到**单调栈**，但栈并不能快速地删除最大值（即栈底元素）。

此时，我们就需要使用双向队列了。队列保存数组下标，并且队头下标对应的值为窗口内的最大值，**队头到队尾下标对应的值满足单调递减**。

同时，需要判断队头对应的最大值是否被当前窗口抛弃。

示例：

```e
 滑动窗口的位置                 双向队列
---------------               ---------
[1  3  -1] -3  5  3  6  7     [3 -1]
 1 [3  -1  -3] 5  3  6  7     [3 -1]
 1  3 [-1  -3  5] 3  6  7     [5]
 1  3  -1 [-3  5  3] 6  7     [5 3]
 1  3  -1  -3 [5  3  6] 7     [6]
 1  3  -1  -3  5 [3  6  7]    [7]
```

## 316 - 去除重复字母 - 困难 - C++

此题可用递归，也可用栈的方法。我使用栈的方法，类似于单调栈。

我们对栈进行这样的规定：

- 如果当前字符 未存在于 栈中，则进行如下判断：
  - 如果，栈顶字符小于当前字符 或 剩余字符串中没有栈顶字符，则压入当前字符
  - 反之，则循环弹出 大于当前字符 且 剩余字符串中存在重复字符 的栈顶字符
- 如果当前字符 已经存在于 栈中，则 跳过 当前字符。

最后，将栈中从底到顶的字符拼接起来，则是去重且字典序最小的字符串。

如何判断字符是否存在于栈中，以及是否还有重复字符，则需使用结构体记录信息。并通过结构体数组将字符映射到对应结构体，比如：字符`ch`对应`structs[ch-'a']`。

## 338 - 比特位计数 - 中等 - C++

动态规划。

比特位长度为`n`的数的总数 `==` 比特位长度为`1~n-1`的数的总数。

并且，长度为`n`数中第`i`个数二进制`1`的数量 `==` 比特位长度为`1~n-1`数中第`i`个数二进制`1`的数量 `+` 1。

例如：

```console
输入: 7
输出: [0,1,1,2,1,2,2,3]
```

0的比特位宽度为`0`，二进制1的数量为：`[0]`；1的比特位宽度为`1`，二进制1的数量分别为：`[0+1] = [1]`；2,3的比特位宽度为`2`，二进1的数量为：`[0+1, 1+1] = [1,2]`；4,5,6,7的比特位宽度为`3`，二进制1的数量为：`[0+1, 1+1, 1+1, 2+1] = [1,2,2,3]`。

## 354 - 俄罗斯套娃信封 - 困难 - C++

动态规划。

一道典型的[最长递增子序列问题](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/)。

先按照宽高从小到大排序，然后用一个**一维数组**记录每个信封可以装下的最多信封个数。

从小到大遍历信封，每计算一个新的信封a，就向前找宽高都小于它的信封b，然后用信封b可装下信封的个数加一。

## 543 - 二叉树的直径 - 简单 - GO

树 + 递归。

一棵树的最大直径可分为三种情况：

- 左子树的直径大
- 右子树的直径大
- 从左子树最深结点出发，经过根结点，到右子树最深结点的路径大

## 898 - 子数组按位或操作 - 中等 - C++

动态规划。

动态规划不一定要用二维数组，需依情况而定，此题只需要O(1)的空间即可。

问题中可能存在 隐性的 可以减少计算的 上限/下限条件，需要去发现并利用。

## 1026 - 节点与其祖先之间的最大差值 - 中等 - GO

我的思路与543题一样，一棵树的最大“差值”可从三种情况中取舍，并用递归实现。

[更优解](https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/solution/java-dfs-by-zxy0917-4/)：

```java
class Solution {
    int res = Integer.MIN_VALUE;

    public int maxAncestorDiff(TreeNode root) {
        if (root == null) return 0;
        //如果当前节点没有子节点，则直接返回
        helper(root, root.val, root.val);
        return res;
    }

    /**
     * 每条从根节点到叶子节点的路径中的最大值和最小值，并求出差值更新全局变量
     */
    private void helper(TreeNode node, int max, int min) {
        if (node == null) return;
        max = Math.max(node.val, max);
        min = Math.min(node.val, min);
        //到达叶子节点，求最大差值
        if (node.left == null && node.right == null) {
            res = Math.max(res, Math.abs(max - min));
        }
        helper(node.left, max, min);
        helper(node.right, max, min);
    }
}
```

利用DFS遍历**每条从根结点到叶子的路径**，通过**函数传参(不使用全局变量是因为：每条路径上的最大最小值是不同的)**记录每条路径的结点最大最小值，从中选出最大“差值”。

## 剑指offer04 - 二维数组中的查找 - 简单 - Python

二分查找。

这虽是一道简单题，但考虑要周全，对于有可能包含目标值（`target >= l[0] and target <= l[len(l)-1]`）的行都要进行二分查找。

二分查找：

```python
lpos = 0
rpos = len(l)
mid = (lpos+rpos) / 2
while rpos-lpos > 1:
    if target >= l[mid]:
        lpos = mid
    else:
        rpos = mid
    mid = (lpos+rpos) / 2
```

[更优解](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/)——从左下角往右上角**斜线搜索**：

- 若当前值大于目标值，则说明当前行的右边和其下的行都大于目标值，则向上移动；
- 若当前值小于目标值，则说明当前行的左边和其上的行都小于目标值，则向右移动；
- 直到匹配到目标值，或移出了二维数组。

## 剑指offer07 - 重建二叉树 - 中等 - C++

先序中序建树。

- 依据先序 根-左-右 特性，可以得知根结点的值；
- 依据中序 左-根-右 的特性和根结点的值，可以划分出左子树的中序数组、根结点和右子树的中序数组；
- 根据左右子树的中序数组的长度，可以从先序数组划分出根结点、左子树的先序数组和右子树的先序数组。

## 剑指offer12 - 矩阵中的路径 - 中等 - C++

DFS。

尝试了两种方法：

1. 在当前函数中判断上下左右单元是否符合，符合再进行递归。时间和空间消耗小，代码长。
2. 在递归函数中再判断当前单元是否符合。时间和空间消耗大，代码短。

## 剑指offer13 - 机器人的运动范围 - 中等 - C++

BFS。

## 剑指offer14 - I-剪绳子 - 中等 - C++

属于动态规划线性模型。

- `dp[i]`表示：`[i, n)` 段绳子的最大乘积（绳子至少被剪一刀）
- 状态转移方程为：`dp[i] = max{ (k-i)*dp[n-k], (k-i)*(n-k) }, i<k<n`

**注意**：要区分于矩阵链相乘问题(区间模型)，矩阵链相同长度的不同部分的最优解是不一样的。

另外，此题使用了备忘录算法的递归方式，更好的方法应该是for循环方式，如下：

- `dp[i]`表示：`[0, i)` 段绳子，即长度为`i`绳子的最大乘积（绳子至少被剪一刀）
- 状态转移方程为：`dp[i] = max{ k*dp[i-k], i*(i-k) }, 0<k<i`

## 剑指offer16 - 数值的整数次方 - 中等 - C++

原本是一道简单的递归题，却被我弄得十分复杂。

有时候，能用递归解决的问题优先考虑递归，然后再转换成循环。

此题递归思路如下：

- 幂n为偶数时，`pow(x,n) = pow(x,n/2) * pow(x,n/2)`
- 幂n为奇数时，`pow(x,n) = pow(x,n/2) * pow(x,n/2) * x`

## 剑指offer20 - 表示数值的字符串 - 中等 - C++

编译原理的词法分析。

用正则表达式去实现，提交后一直爆出各种问题，包括时不时的编译错误。。。终于知道为何这道题的通过率这么低了。

## 剑指offer44 - 数字序列中某一位的数字 - 中等 - C++

第一种思路：设置当前下标`i`，当前数字`num`，当前数字的位数`num_count`。当`i<n`时，`num++`，若`num`的位数增加了，则`num_count++`，最后`i += num_count`。循环结束后，根据`i`和`n`的差值，就可以求出对应的数字。

第二种思路：因为`0~9`、`10~99`、`100~999`等等之间的数，位数是固定的。所以，可以直接通过**数学**方程去求解。

第一种思路的题解可能会超时，也可能不会，第二种显然更加简单快速。

## 剑指offer48 - 最长不含重复字符的子串 - 中等 - C++

双指针（滑动窗口）。

一开始，我的思路是动态规划。然而，这道题用动态规划之后的时间复杂度，似乎跟暴力破解差不多。（可能是最近动态规划学傻了。。。）

动态规划的思路想了许久，发现不对劲，于是去看[题解](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/tu-jie-hua-dong-chuang-kou-shuang-zhi-zhen-shi-xia/)。题解使用的是**滑动窗口**算法，虽然本质上是**暴力算法**的改进，但这方法实在太妙了。

## 剑指offer63 - 股票的最大利润 - 中等 - C++

只需要O(1)空间的动态规划。

遍历每天的股票价格，用一个变量`min`记住当天之前的股票最小值，用一个变量`max`记住股票的最大利润。如果 `当天股价 - min > max`，则使`max = 当天股价 - min`。

## LCP5发LeetCoin - 困难 - C++

**数组储存树** + 双向树。

用数组储存树，能达到通过下标快速索引的效果。

关键：每个结点都具有指向父结点的“指针”，每次更新结点的`coins`值，都要相对应地更新祖先结点的`coins`值。
