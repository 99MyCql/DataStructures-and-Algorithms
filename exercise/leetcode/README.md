# leetcode 刷题记录

[TOC]

## 前言

简单题记录较少，多为中等与困难题。

部分经典题型的详细解法在 `note\` 目录下。

## 2 - 两数相加 - 中等 - 链表

## 3 - 无重复字符的最长子串 - 中等 - 滑动窗口

## 4 - 寻找两个正序数组的中位数 - 困难 - 特殊

不会，直接看题解：找第k个数。两个数组中的中位数，其实就是两个数组中第 `k = (m+n)/2` 个数。

思路不难理解，但是边界情况很多，处理起来很麻烦。

## 5 - 最长回文子串 - 中等 - 动态规划

见`note\algorithms\dp.md`。

## 10 - 💀正则表达式匹配 - 困难 - 动态规划

一开始还想通过遍历方式求解，但显然不行，还得是动态规划。

在编写状态转移方程时，对于 `p[j] == '*'` 情况的分析是难点。我们可以根据以下情况进行分类：

- `*` 前面的字符 `p[j-1]` 重复零次，那么 `dp[i][j] = d[i][j-2]` 。
- `*` 前面的字符 `p[j-1]` 重复多次：
  - `s[i] == p[j-1]` ，重复1次，那么 `dp[i][j] = dp[i-1][j-2]` 。
  - 且 `s[i-1] == p[j-1]` ，重复2次，那么 `dp[i][j] = dp[i-2][j-2]` 。
  - 且 `s[i-x+1] == p[j-1]` ，重复x次，那么 `dp[i][j] = dp[i-x][j-2]` 。

  一直这样向前推，似乎有点蠢。其实，这其中隐藏着一个规律：如果 `dp[i][j]` 满足 `p[j-1]` 重复 x 次，那么把 `s[i]` 去掉， `dp[i-1][j]` 满足重复 x-1 次。
  因此，当 `s[i] == p[j-1]` 且 `*` 前面的字符 `p[j-1]` 重复 `>=1` 次时，可以归纳为 `dp[i][j] = dp[i-1][j]` 。

## 11 - ⭐盛最多水的容器 - 中等 - 双指针

不会，看题解。双指针，背后思想是 **缩减搜索空间**，具体请看：<https://leetcode.cn/problems/container-with-most-water/solution/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu/> 。

## 15 - ⭐三数之和 - 中等 - 双指针

在有序数组nums中，找两个数相加等于某一个数，可以采用双指针实现`O(n)`复杂度。p指向数组头，q指向数组尾。如果`nums[p]+nums[q] < target`，则`p++`。如果`nums[p]+nums[q] > target`，则`q--`。因此，本题可以先将数组排序，然后固定一个数 `nums[i]` ，在数组中找两个数，之和为 `-nums[i]` 。

题目的关键在于去重。参考39题，组合问题，需要按照某种顺序进行遍历/搜索，使用 begin 变量，才能防止重复。因此，本题只要保证每个三元组 `(nums[i], nums[p], nums[q])` 中 `nums[i] < nums[p] < nums[q]` ，就能防止重复。即 i 从 0 开始遍历， p 从 i+1 开始遍历，q 从反向遍历但必须大于 p 。此外，遍历 nums[i] 和 nums[p] 时要跳过重复元素。

## 17 - 电话号码的字母组合 - 中等 - 回溯/队列

## 19 - 删除链表的倒数第N个结点 - 中等 - 双指针

两个指针，第一个指针从头到尾遍历链表，当遍历到第`N+1`个结点时，第二个指针从第`1`个结点开始遍历。此后，两个指针同步前进，相隔保持`N`个结点。直到第一个指针到达最后一个`NULL`结点，两个指针停止，此时第二个指针指向倒数第`N`个结点。

## 22 - 括号生成 - 中等 - 递归回溯

## 23 - 合并K个排序链表 - 困难 - 归并/优先队列

多种解法，较优的方法有：归并、优先队列。

## 31 - 下一个排列 - 中等 - 字典序算法

[字典序算法](https://blog.csdn.net/happyrocking/article/details/83619392)。

## 32 - 最长有效括号 - 困难 - 栈

解法：

1. 栈。遇到 `(` 入栈。遇到 `)` ，若栈顶为 `(` 则弹出，并计算当前位置与栈顶元素位置之间的距离（它们之间都是有效括号）；若栈顶为 `)` ，则入栈。
2. 遍历。从左到右遍历字符串，遇到 `(` ，左括号累计数量 `lCnt++` ；遇到 `)` ，右括号累计数量 `rCnt++` 。当 `rCnt == lCnt` 时记录长度，当 `rCnt >= lCnt` 时则将 `lCnt` 和 `rCnt` 清零。一开始也想到类似这种解法，但想不到怎么解决 `(()` 的情况。题解的方法是从右到左再遍历一遍。

## 33 - 搜索旋转排序数组 - 中等 - 分治

升序数组在某点旋转后，会变成两段升序子数组，由于升序子数组依旧具有升序特性，所以可以使用二分法求解，即分治算法。

只是在二分的时候，需要更复杂的条件判断。

同时，二分法需要注意边界问题：

```go
if target < nums[mid] {
    search(nums[:mid], target) // 切片 [:mid] 不包括 mid
}

if target >= nums[mid] {
    search(nums[mid:], target)
}
```

## 33 - 搜索旋转排序数组 - 中等 - 二分

对于非常规升序的数组，需要找到规律改进二分。

## 34 - 在排序数组中查找元素的第一个和最后一个位置 - 中等 - 二分

二分不仅可以用来查找有序数组中某个确定的值，还可以查找第一个/最后一个满足条件的值。

## 39 - ⭐组合总和 - 中等 - 回溯

原本思路是回溯，但担心超时，就想用DP进行优化，结果碰到序列重复的问题，`[2,3,2]` 和 `[2,2,3]` 是同一个组合。

看了题解，还是得用回溯。当 `target` 较小而 `candidates[i]` 较大时，时间复杂度并不高。而且这道题无法用状压DP，按我的思路DP是三维的。在递归回溯过程中，需要按照顺序进行递归，上一个选过的数，下一轮递归时不应被选择，以此解决序列重复的问题。

[题解](https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/)的总结：

- 排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；
- 组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 begin 变量。

## 42 - ⭐接雨水 - 困难 - 单调栈

一开始的思路：找先递减后递增的V字区域，统计V字区域内的水量总和。解答错误！会有W区域的情况，两个V区域的上方依旧可以积水。

改进的思路：对于一个峰值（递增路径上的最后一个点）所在的位置，向右遍历找大于该值的第一个峰值（其实值也可以）。若找到，统计这一片区域内的水量，若未找到，记录最大值，统计峰值到最大值区域内的水量。

题解思路：单调栈。栈内元素对应的值递减，若遇到比栈顶值大的，则弹出，计算水量，直到比栈顶值小，核心代码：

```c
while (!s.empty() && height[i] > height[s.top()]) {
    int t = s.top();
    s.pop();
    if (!s.empty()) sum += (i-s.top()-1)*(min(height[s.top()], height[i])-height[t]);
}
```

## 45 - 跳跃游戏 II - 中等 - 动态规划

## 46 - 全排列 - 中等 - 回溯

## 48 - 旋转图像 - 中等 - 矩阵旋转

每次处理一个位置的一圈的旋转，`[i][j] -> [j][n-1-i] -> [n-1-i][n-1-j] -> [n-1-j][i] -> [i][j]`。

## 52 - N皇后II - 困难 - 栈/递归

此题用递归回溯的方法更加容易，但也可以用栈的方法实现。

## 53 - ⭐最大子数组和 - 中等 - 动态规划

动态规划经典题。关键是定义**无后效性**的子问题：`dp[i]`表示以`nums[i]` **结尾** 的连续子数组的最大和。然后，状态转移方程为：`dp[i] = max(dp[i-1]+nums[i], nums[i])`。

## 55 - 跳跃游戏 - 中等 - 动态规划

## 56 - 合并区间 - 中等 - 排序+双指针

注意细节：`[1,4]` 与 `[2,3]` 合并为 `[1,4]`。

## 62 - 不同路径 - 中等 - 动态规划

## 64 - 最小路径和 - 中等 - 动态规划

## 72 - 编辑距离 - 困难 - 动态规划

类似于最长公共子序列。

## 76 - ⭐最小覆盖子串 - 困难 - 滑动窗口

整体思路没错，但有些细节考虑不周：

1. 滑动窗口应该考虑清楚 i 和 j 滑动的规则。在此题中，当窗口中未包含 `t` 中的所有字符，则 `j++` ；如果已包含，则 `i++` 直到窗口未包含 `t` 中的所有字符。
2. 当出现满足条件的子串，只需要记录子串的左右边界，不需要记录整个子串（会超出内存限制）。在记录子串的左右边界时，直接判断是否小于最小值，只有小于最小值才记录下来。

## 78 - 子集 - 中等 - 排列组合(递归)

简单的排列组合问题，递归解决即可。

对于`[1,2,3]`，3个中取2个组合，即：

- 将1加入，对`[2,3]`2个中取1个组合所产生的各个集合`[[2],[3]]`中，变成`[[1,2],[1,3]]`；
- 将2加入，对`[3]`1个取1个组合所产生的各个集合`[[3]]`中，变成`[[2,3]]`；
- ~~将3加入，对`[]`0个取1个组合所产生的各个集合`[[]]`中~~ 由于`[]`为空，不能进入组合；
- 最终，合并为`[[1,2],[1,3],[2,3]]`

由上述示例可知，构造一个函数（类似于$C_b^a$）：从`b`中取`a`个组合，并返回对应集合。然后，递归调用该函数即可。

## 79 - 单词搜索 - 中等 - 回溯

## 80 - 删除有序数组中的重复项 II - 中等 - 滑动窗口

新数组一定短于原数组，因此新数组可以直接基于原数组构建，遍历原数组把符合条件的元素追加到新数组最后即可。

题解中使用了更优的条件判断方法：新数组中新元素是 `nums[p]` ，原数组当前元素是 `nums[i]` ，只要 `nums[p-2] != nums[i]` 就能 `nums[p] = nums[i]` 。

## 84 - ⭐柱状图中的最大矩形 - 困难 - 单调栈

解法有很多种，我使用了两种解法：

- 暴力解法：`0 <= i < n` 进行遍历，对于每次的 `i` ，再使 `i < j < n` 进行遍历。`j` 遍历过程中，记录 `i ~ j` 区间内柱子高度的最小值 `min` ，并计算矩形面积 `(j - i) * min`。最后，从所有矩形面积中取最大值。

- 单调栈。求以第 i 个柱子高度 h[i] 为宽的矩形的最大面积，只需要找到第 i 个柱子左右两边第一个高度小于 h[i] 的柱子，以这两个柱子之间的距离为矩形的长。单调栈中，按柱子高度单独递增。

参考：

- [官方题解](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode/)

- [找两边第一个小于它的值](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhao-liang-bian-di-yi-ge-xiao-yu-ta-de-zhi-by-powc/)

## 85 - 最大矩形 - 困难 - 单调栈

解法依旧有很多种，我选择了84题的延申解法，即：将 `0~i` 行看成柱状图，使用84题求柱状图中的最大矩形，`i` 从 `0~n` 遍历，取每一次遍历结果中最大值。

参考：

- [官方题解](https://leetcode-cn.com/problems/maximal-rectangle/solution/zui-da-ju-xing-by-leetcode/)

## 92 - 反转链表II - 中等 - 链表头插法

## 105 - 从前序与中序遍历序列构造二叉树 - 中等 - 二叉树

根据前序和后序的规律，递归即可构造。

题解的思路：

1. 递归，可以用hashmap存前序中节点对应中序中的位置，就不用每次都遍历两个数组。
2. 迭代，有点复杂，不想看了。

## 114 - 二叉树展开为链表 - 中等 - 递归

先将左子树和右子树转换成链表，然后将左子树链表连接于根结点右边、右子树链表连接于左子树链表之后。

## 122 - ⭐买卖股票的最佳时机 II - 中等 - 动态规划/贪心

动态规划关键：`dp[i][j]` 定义为第i天持有j个股票。这里要用持有多少个股票作为DP状态，而不应该用买入卖出操作作为状态。

## 123 - 买卖股票的最佳时机 III - 中等 - 动态规划

与122题类似，`dp[i][j]` 表示第i天处于j状态时的最大利润，j有五种情况：0代表还没进行任何交易、1代表已买入第一股、2代表已卖出第一股、3代表已买入第二股、4代表已卖出第二股。

## 135 - 💡分发糖果 - 困难 - 左右两次遍历/BFS

我的思路：BFS。先将同时小于左右分值的元素加入到队列中，它们的糖果数量为1；弹出队列中元素，将这些元素左右分值大于该元素而糖果数量较小的，加入到队列中，糖果数量设为2；如此循环处理，直至队列为空。

题解：左右两次遍历。先从左到右遍历，若 `nums[i] > nums[i-1]` ，则 `left[i] = left[i-1]+1` ；再从右到左遍历，若 `nums[i] > nums[i+1]` ，则 `right[i] = right[i+1]+1` ；最后，`max(left[i],right[i])`。

## 142 - ⭐环形链表II - 中等 - Floyd判圈算法——快慢指针

## 146 - ⭐LRU 缓存 - 中等 - 双向链表+哈希表

可以使用STL中的list作为双向链表。这种方式下，哈希表的value是list的迭代器，为了方便删除链表中间结点。一个新的结点 `l.push_front(node)` 之后，可以通过 `l.begin()` 获取它的迭代器。

## 148 - 排序链表 - 中等 - 归并排序

找链表中点可以用快慢指针。

## 150 - 逆波兰表达式求值 - 中等 - 栈

操作数栈，遇到运算符就弹出栈顶两个元素进行运算，再将结果压栈。

## 152 - 乘积最大子数组 - 中等 - 动态规划

53题最大子数组和的变型。

一开始的思路：暴力遍历O(n^2)，压线过了。

看题目应该是要用动态规划，但没有思路，看了题解：与53题类似，子问题`dp[i]`可以定义为以`nums[i]`结尾的子数组中乘积最大值。但是，数组中存在负数，`dp[i-1]*nums[i]`可能导致最大值变为最小值，而以`nums[i]`结尾的子数组中乘积最小值，可能变为最大值。因此，需要记录最大值和最小值，状态转移方程如下：

```c
max_dp[i] = max(max(max_dp[i-1]*nums[i], nums[i]), min_dp[i-1]*nums[i]);
min_dp[i] = min(min(max_dp[i-1]*nums[i], nums[i]), min_dp[i-1]*nums[i]);
```

## 155 - 最小栈 - 简单 - 单调栈

## 160 - 相交链表 - 简单 - 链表

先计算出两个链表的长度，然后用指针`long`指向长链表，指针`short`指向短链表。`long`指针先走 长短链表差值 的步数，此时`short`指针再开始与`long`指针同步前进，若途中两个指针相等，则说明链表相交。

## 162 - 寻找峰值 - 中等 - 二分

注意：数组中有递增也有递减。

二分找满足 `A[mid] > A[mid+1]` 条件的第一个值，即为峰值。

## 189 - ⭐轮转数组 - 中等 - 数组翻转

还得是题解，三步完成：

```c
reverse(nums,0,nums.size());
reverse(nums,0,k);
reverse(nums,k,nums.size());
```

## 198 - 打家劫舍 - 中等 - 动态规划

理解关键一点：先打劫第 1 家，得到的最大金额 = 第 1 家金额 + 第 3-n 家的最大金额；先打劫第 2 家，得到的最大金额 = 第 2 家金额 + 第 4-n 家的最大金额；而如果先打劫第 3 家，那还可以回去打劫第 1 家，相当于先打劫第 1 家的情况。

动态规划：

1. dp[i] 表示 [0,i]的最大金额。
2. dp[i] = max(nums[i]+dp[i-2], nums[i-1]+dp[i-3])。
3. dp[1] = nums[1], dp[2] = max(nums[1],nums[2])。

## 207 - 课程表 - 中等 - 拓扑排序

经典拓扑排序。用一个数cnt记录已处理的课程数据，最后通过判断cnt是否等于numCourses来判断是否存在环。

## 208 - 实现 Trie (前缀树) - 中等 - Trie树

用类表示结构体。

## 224 - 基本计算器 - 困难 - 栈

用两个栈（操作数栈和运算符栈）求解表达式。

## 225 - 用队列实现栈 - 简单 - 队列

两个队列。入栈时，将元素压入其中一个不为空的队列；出栈时，将 `n-1` 个元素从不为空的队列中弹出，并压入另一个空队列中，最后弹出剩下的第 `n` 个元素，即栈顶元素；通过一个 `top` 变量记录栈顶元素，获取栈顶元素时，直接返回 `top` 变量。

## 232 - 用栈实现队列 - 简单 - 栈

一个栈A，一个栈B。入队时，将元素压入栈A；出队时，将元素从栈B中弹出。如果栈B为空，则将栈A中元素依次弹出、压入栈B。

## 238 - 除自身以外数组的乘积 - 中等 - 前缀积

## 239 - ⭐滑动窗口的最大值 - 困难 - 单调队列

由于窗口是滑动的，所以某次窗口内的最大值，最终会被抛弃在窗口之外，此时就需要扶持原本的第二大值上位了。

那么如何快速地找到第二大值呢？我们可能会想到**单调栈**，但栈并不能快速地删除最大值（即栈底元素）。

此时，我们就需要使用双向队列了。队列保存数组下标，并且队头下标对应的值为窗口内的最大值，**队头到队尾下标对应的值满足单调递减**。

同时，需要判断队头对应的最大值是否被当前窗口抛弃。

示例：

```e
 滑动窗口的位置                 双向队列
---------------               ---------
[1  3  -1] -3  5  3  6  7     [3 -1]
 1 [3  -1  -3] 5  3  6  7     [3 -1]
 1  3 [-1  -3  5] 3  6  7     [5]
 1  3  -1 [-3  5  3] 6  7     [5 3]
 1  3  -1  -3 [5  3  6] 7     [6]
 1  3  -1  -3  5 [3  6  7]    [7]
```

## 240 - 💡搜索二维矩阵 II - 中等 - 二维二分

不会二维二分，看题解：

1. 从 **右上角** 开始搜索，大于 target 向左走，小于 target 向下走。
2. 取矩阵中心值，将矩阵分成左上、右上、左下、右下四个小矩阵。如果中心值大于 target ，丢弃右下矩阵，递归处理其它三个矩阵；如果中心值小于 target ，丢弃左上矩阵，递归处理其它三个矩阵。

## 274 - H 指数 - 中等 - 排序

## 300 - 最长递增子序列 - 中等 - 动态规划

经典动态规划题，非常容易在 O(n^2) 内解决。

但要求降低到 O(nlogn) ，不会。题解：用二分取代第二轮循环，提出一个tail数组，`tail[i]` 代表长度为 `i+1` 的子序列尾部元素最小的值，满足严格递增性质，具体参考：<https://leetcode.cn/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/> 。

## 316 - 去除重复字母 - 困难 - 栈

此题可用递归，也可用栈的方法。我使用栈的方法，类似于单调栈。

我们对栈进行这样的规定：

- 如果当前字符 未存在于 栈中，则进行如下判断：
  - 如果，栈顶字符小于当前字符 或 剩余字符串中没有栈顶字符，则压入当前字符
  - 反之，则循环弹出 大于当前字符 且 剩余字符串中存在重复字符 的栈顶字符
- 如果当前字符 已经存在于 栈中，则 跳过 当前字符。

最后，将栈中从底到顶的字符拼接起来，则是去重且字典序最小的字符串。

如何判断字符是否存在于栈中，以及是否还有重复字符，则需使用结构体记录信息。并通过结构体数组将字符映射到对应结构体，比如：字符`ch`对应`structs[ch-'a']`。

## 338 - 比特位计数 - 中等 - 动态规划

比特位长度为`n`的数的总数 `==` 比特位长度为`1~n-1`的数的总数。

并且，长度为`n`数中第`i`个数二进制`1`的数量 `==` 比特位长度为`1~n-1`数中第`i`个数二进制`1`的数量 `+` 1。

例如：

```console
输入: 7
输出: [0,1,1,2,1,2,2,3]
```

0的比特位宽度为`0`，二进制1的数量为：`[0]`；1的比特位宽度为`1`，二进制1的数量分别为：`[0+1] = [1]`；2,3的比特位宽度为`2`，二进1的数量为：`[0+1, 1+1] = [1,2]`；4,5,6,7的比特位宽度为`3`，二进制1的数量为：`[0+1, 1+1, 1+1, 2+1] = [1,2,2,3]`。

## 347 - 前 K 个高频元素 - 中等 - 堆

前K大，用小顶堆。

## 354 - 俄罗斯套娃信封 - 困难 - 动态规划

一道典型的[最长递增子序列问题](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/)。

先按照宽高从小到大排序，然后用一个**一维数组**记录每个信封可以装下的最多信封个数。

从小到大遍历信封，每计算一个新的信封a，就向前找宽高都小于它的信封b，然后用信封b可装下信封的个数加一。

## 394 - 字符串解码 - 中等 - 栈

我的解法：先用栈求出左右括号匹配关系，存在map中。然后，遍历字符串，碰到数字求出k值（注意这里k是1~300），递归处理括号内字符串（通过左括号能知道右括号的位置，进而可以直接截取这一段字符串）。

题解：

1. 用两个栈，一个存数字，一个存字符串。碰到数字，计算值入栈；碰到左括号，将当前字符串入栈，并清空当前字符串；碰到右括号，将当前字符串*数字栈栈顶值，再加上字符串栈栈顶值，再将字符串栈栈顶弹出，成为新的当前字符串。
2. 递归。碰到左括号，递归处理剩余字符串，将结果乘于次数再加上当前字符串；碰到右括号返回当前字符串，和这段字符串的长度。

感觉，我的解法虽然多了一步，但后续递归比较好理解，题解是有点绕的。

## 417 - 太平洋大西洋水流问题 - 中等 - DFS

数据量小没必要DP。逆向DFS思路。

## 448 - 💡找到所有数组中消失的数字 - 简单 - 脑筋急转弯

不会改进，看题解：原地修改，具体直接看代码。

## 460 - ⭐LFU缓存 - 困难 - 双哈希表+双向链表

参考题解：<https://leetcode.cn/problems/lfu-cache/solutions/2457716/tu-jie-yi-zhang-tu-miao-dong-lfupythonja-f56h/>

两个 Map ，一个是 key 到 结点 的映射，一个是 频率 到 双向结点链表 的映射。

一些关键点：

- 因为频率相同时需按照LRU的方法删除，所以第二个Map的值为双向链表。同时，**双向链表的头结点的prev指向最后一个结点**，方便直接删除最后一个结点。
- 因为时间复杂度要求为 O(1) ，所以需要用 **unordered_map** 。而为了删除频率最小的结点，需要用 **min_freq** 记住当前的最小频率。当 put 时， min_freq 直接设置为 1 ；当 get 时，将结点从 freq 链表转移到 freq+1 链表，若 freq==min_freq 且该结点是唯一一个结点，则令 min_freq++ 。
- 按照题目要求，put 时若 key 已存在，则更新其值，并将其频率+1。

## 467 - 环绕字符串中唯一的子字符串 - 中等

双层循环找符合的子串加入集合，时间复杂度O(n^2)，超时。

正确方法：找以某个字母开头的最长子串的长度，该长度代表以该字母开头的所有唯一子串个数。

## 473 - 火柴拼正方形 - 中等 - 回溯/状态压缩DP

所有火柴必选且是正方形，所以可以先判断是否整除4，如果可以再求出边长度。

回溯：递归遍历所有火柴，如果能拼接进四边中一边则拼入，而后递归下一根火柴，否则直接返回错误。遍历完所有火柴，若四边都等于规定长度，则返回正确，否则返回错误。

状态压缩DP：当前状态的上一个状态包括：当前状态对应的火柴集合中去掉第k根火柴。状态不用四条边数组表示，而是用一个整数表示，其表示当前未拼接好的边的长度。

## 538 - 把二叉搜索树转换为累加树 - 中等 - 二叉树中序遍历

“右-中-左”中序遍历二叉树，按这个顺序计算累加值并更新每个节点的值。

## 543 - 二叉树的直径 - 简单 - 树+递归

一棵树的最大直径可分为三种情况：

- 左子树的直径大
- 右子树的直径大
- 从左子树最深结点出发，经过根结点，到右子树最深结点的路径大

## 560 - ⭐和为 K 的子数组 - 中等 - 前缀和优化

我的思路：1. 滑动窗口，但对于存在负数的情况，无法正确求解；2. 暴力遍历 O(n^2) 。

题解：

对于区间`[j,i]`，可以通过前缀和数组快速求出区间的和：`S[i]-S[j]`。但如果遍历前缀和数组，时间复杂度依旧是 O(n^2) 。

其实不用关心哪两项的前缀和之差为 k ，只需要关心前缀和之差为 k 出现的次数。遍历前缀和数组，对于 `S[i]` ，查询是否存在 `S[j] = S[i]-k` 。若存在，则查询有多少个这样的 `S[j]` ，将这个数量加到总数中。可以用一个 hash map 来保存前缀和值对应的数量。

## 668 - 乘法表中第k小的数 - 困难 - 二分

当Y=F(X)随着X递增而递增（或递增而递减），则可以在X范围内二分，并用Y判断，使Y接近目标值。

```c
int l = 1, r = m*n;
while (l < r) {
    int mid = (l+r) / 2;
    int cnt = mid/n * n;
    for (int i = mid/n + 1; i <= m; i++) {
        cnt += mid/i;
    }
    if (cnt >= k) r = mid;
    else l = mid+1;
}
return l;
```

## 739 - 每日温度 - 中等 - 单调栈

单调栈问题可以先在纸上把出栈入栈的规则写清楚。

## 875 - 爱吃香蕉的珂珂 - 中等 - 二分

速度k的范围是1到piles数组中的最大值。

对于每个k，遍历piles数组求计算出总耗时h_sum，与h比较，若小于等于h，则满足条件。且，当k越小h_sum越大，k越大h_sum越小。

我们可以从小到大遍历k，找到满足条件的最小值。但 `1 <= piles[i] <= 10^9` ，数据范围太大。

不过，由于k是递增，且与h_sum负相关，则可以用二分找满足条件的最小值。

## 898 - 子数组按位或操作 - 中等 - 动态规划

动态规划不一定要用二维数组，需依情况而定，此题只需要O(1)的空间即可。

问题中可能存在 隐性的 可以减少计算的 上限/下限条件，需要去发现并利用。

## 1026 - 节点与其祖先之间的最大差值 - 中等 - 递归

我的思路与543题一样，一棵树的最大“差值”可从三种情况中取舍，并用递归实现。

[更优解](https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/solution/java-dfs-by-zxy0917-4/)：

```java
class Solution {
    int res = Integer.MIN_VALUE;

    public int maxAncestorDiff(TreeNode root) {
        if (root == null) return 0;
        //如果当前节点没有子节点，则直接返回
        helper(root, root.val, root.val);
        return res;
    }

    /**
     * 每条从根节点到叶子节点的路径中的最大值和最小值，并求出差值更新全局变量
     */
    private void helper(TreeNode node, int max, int min) {
        if (node == null) return;
        max = Math.max(node.val, max);
        min = Math.min(node.val, min);
        //到达叶子节点，求最大差值
        if (node.left == null && node.right == null) {
            res = Math.max(res, Math.abs(max - min));
        }
        helper(node.left, max, min);
        helper(node.right, max, min);
    }
}
```

利用DFS遍历**每条从根结点到叶子的路径**，通过**函数传参(不使用全局变量是因为：每条路径上的最大最小值是不同的)**记录每条路径的结点最大最小值，从中选出最大“差值”。

## 1143 - 最长公共子序列 - 中等 - 动态规划

见`note\algorithms\dp.md`。

## 1163 - 💡按字典序排在最后的子串 - 困难 - 双指针

字典序排在最后的子串的首字符，一定是主串中最大的字符，因此先找到主串中最大的字符。但主串中可能有多个最大字符，以哪个最大字符为首的子串才是答案呢。

`i` 指向第一个最大字符，`j` 指向第二个最大字符，`k` 从0开始：

- 如果 `s[i+k] == s[j+k]` ，则 `k++` 。
- 如果 `s[i+k] > s[j+k]` ，说明以 `s[j:j+k]` 中的任意字符 `c` 作为首字符的子串 `sj` ，相比 `s[i:i+k]` 中的对应字符 `c'` 作为首字符的子串 `si` ， `sj` 的字典序一定小于 `si` 的字典序。那么，舍弃 `s[j:j+k]` ，令 `j` 从 `j+k+1` 开始，找到下一个最大字符。
- 如果 `s[i+k] < s[j+k]` ，同理，说明 `s[i:i+k]` 应该被舍弃。但如果 `i+k` 大于等于 `j` ，那 `s[j:j+k]` 中有一部分也会被舍弃（这里需要证明一下，但我懒了）。

最终，`s[i:n-1]` 即为答案子串。

## 2597 - 美丽子集的数目 - 中等 - 位集合

我的思路：先把绝对差为k的数都用二进制形式记录下来，比如，第0个和第1个数相差为k，则记录(011)。然后遍历所有的子集，如果子集的二进制比特位表示 `&` 上记录中的数等于这个数，则说明子集中存在相差为k的两个数，不算进美丽子集数目中。

## 2781 - 💀最长合法子字符串的长度 - 困难 - 哈希+双指针 / AC自动机 / 线段树

周赛第4题。

不会做，直接看题解：

1. 哈希表+双指针。虽然 forbidden 数组长度为 10^5 ，但数组中每个字符串长度只有 10 。因此，可以使用哈希表把这些字符串记录下来。然后使用双指针遍历 word ，每次 j++ 判断区间末尾长度在10之内的子串是否在哈希表中，若存在则更新 i 值。
2. AC自动。看不懂，有机会再学。
3. 线段树。看不懂。

## 2812 - 找出最安全路径 - 中等 - 多源BFS

周赛第3题。当时采用DP的解法，但解答错误，原因是：路径可能会向左上两个方向往回走，无法DP。

看了题解。先用**多源BFS**求各点的最小曼哈顿距离；再取 `dis[0][0]` 和 `dis[n-1][n-1]` 中的最小值 max ；遍历 0~max 判断是否存在从 (0,0) 到 (n-1,n-1) 的路径，取这些路径安全系数中最大值。

在遍历 0~max 过程中，可以采用**倒序**，或者**二分**。在判断是否存在从起点到终点的路径时，可以采用 **BFS** ，有题解采用并查集。

## 2817 - 💡限制条件下元素之间的最小绝对差 - 中等 - 平衡树

周赛第3题。当时思路没问题，只是没找到这样的库和函数，能够插入即排序，并且能在 O(logn) 时间内进行范围查找。

看了题解。使用 `multiset` 结构的 `lower_bound()` 函数即可，获取指向第一个大于等于 key 的元素的迭代器。

值得注意的是：使用 iterator 时，需要判断是否超越界限。

## 6109 - 知道秘密的人数 - 中等 - 前缀和

## 6449 - ⚠️收集巧克力 - 中等 - 贪心

注意：long long的最大值用 0x7fffffffffffffff 或 LLONG_MAX 。

## 6472 - ⭐查询后矩阵的和 - 中等 - 逆向思维

周赛第三题。

这种多次修改状态并求最终状态的问题，可以优先考虑逆向思维，即获取某个位置的最后状态，只需关注该位置最后一次变化即可。

## 6893 - ⭐特别的排列 - 中等 - 状态压缩DP

据说是经典状压DP题。

状态压缩DP本质就是将集合的状态用整数表示。当集合元素较少时（小于64位），就可以采用这种方法，此题集合长度为14。

此题比较容易想到的一种思路是：dfs，每次从集合中选择一个满足 `nums[i] % nums[i+1] == 0 || nums[i+1] % nums[i] == 0` 且还未被选择的元素，加入到序列中；当集合中所有元素都被选择完，则特别排列的总数目+1；当集合元素都被选择完，或集合中没有满足条件的元素，则回溯。这种思路时间复杂度大概为 `O(n^n)` ，超时。

正确思路1：记忆化搜索。在dfs思路中，**需要保存集合中元素是否已被选择的状态**，由于此题集合长度为14，因此这个状态可以用一个整数表示。**整数的每一位取1或取0，表示集合中对应元素已被或未被选择**。此外，还需要保存上一个被选择的数，用于判断下一个数是否满足条件。递归函数定义为 `dfs(usedMask, pre)` ，边界为 `dfs(2^n-1, i) = 1`，入口是 `dfs(1<<i, i), i∈(0,n-1)`。对于同一个 `dfs(i,j)` ，可能被多次访问，因此可以用一个二维数组把函数结果保存下来。

正确思路2：动态规划。DP问题都可以将递归转换为自下而上的递推。`dp[i][j]` 中 `i` 表示已选择的集合、`j` 表示上一个被选择的数，边界 `dp[2^n-1][i] = 1` ，状态转移方程为 `dp[i][j] = Σdp[i+{k}][k]` ，结果为 `Σdp[1<<i][i]`。注意：这种解法中 `i` 从大到小遍历，跟常规DP不太一样。一些题解中，将 `i` 表示为未被选择的集合，因此 `i` 从小到大遍历，似乎他们的解法写起来更好理解。

## 6911 - ⭐不间断子数组 - 中等 - 滑动窗口+平衡树

没做出来，看了题解。

对于题目给出的要求，只要保证区间内的最大值-最小值小于2即可。我们需要一个结构，既能快速找到集合中的最大值和最小值，又能根据集合变化实时更新。这个结构就是**平衡树**，C++的map就是一个平衡树结构，`m.begin()`获取最小值，`m.rbegin()`获取最大值。使用 map 维护区间内的数，当最大值-最小值小于2时，j++；当大于2时，移除第i个数，i++，直到最大值-最小值小于2。由于区间内的数会重复出现，可以用 map 的 key 表示这个数，value 存储数出现的次数，当次数等于0时，删除这个数。

我看有些题解，也可以使用两个**单调队列**来维护区间的最大值和最小值，解法类似于第239题。

## 6929 - ⭐数组的最大美丽值 - 中等 - 二分/双指针

我的思路：将每个 `nums[i]` 都转换成区间 `[nums[i] - k, nums[i] + k]` ，然后排序，再求最大重叠区间个数。求重叠区间，只需判断 `arr[i][1] >= arr[j][0]` 即可。一开始我采用两层循环，O(n^2)，超时。比赛最后时刻，突然想起：在有序序列中，求满足条件的一个数，可以用 **二分** 啊！！！

大佬题解：滑动窗口。其实不用转换成复杂的区间重叠问题，先排序，再用滑动窗口求满足 **区间右值 - 左值 <= 2k** 的最长区间即可。

## 剑指offer04 - 二维数组中的查找 - 简单 - 二分

这虽是一道简单题，但考虑要周全，对于有可能包含目标值（`target >= l[0] and target <= l[len(l)-1]`）的行都要进行二分查找。

二分查找：

```python
lpos = 0
rpos = len(l)
mid = (lpos+rpos) / 2
while rpos-lpos > 1:
    if target >= l[mid]:
        lpos = mid
    else:
        rpos = mid
    mid = (lpos+rpos) / 2
```

[更优解](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/)——从左下角往右上角**斜线搜索**：

- 若当前值大于目标值，则说明当前行的右边和其下的行都大于目标值，则向上移动；
- 若当前值小于目标值，则说明当前行的左边和其上的行都小于目标值，则向右移动；
- 直到匹配到目标值，或移出了二维数组。

## 剑指offer07 - 重建二叉树 - 中等 - 先序中序建树

- 依据先序 根-左-右 特性，可以得知根结点的值；
- 依据中序 左-根-右 的特性和根结点的值，可以划分出左子树的中序数组、根结点和右子树的中序数组；
- 根据左右子树的中序数组的长度，可以从先序数组划分出根结点、左子树的先序数组和右子树的先序数组。

## 剑指offer12 - 矩阵中的路径 - 中等 - DFS

尝试了两种方法：

1. 在当前函数中判断上下左右单元是否符合，符合再进行递归。时间和空间消耗小，代码长。
2. 在递归函数中再判断当前单元是否符合。时间和空间消耗大，代码短。

## 剑指offer13 - 机器人的运动范围 - 中等 - BFS

## 剑指offer14 - I-剪绳子 - 中等 - 动态规划

属于动态规划线性模型。

- `dp[i]`表示：`[i, n)` 段绳子的最大乘积（绳子至少被剪一刀）
- 状态转移方程为：`dp[i] = max{ (k-i)*dp[n-k], (k-i)*(n-k) }, i<k<n`

**注意**：要区分于矩阵链相乘问题(区间模型)，矩阵链相同长度的不同部分的最优解是不一样的。

另外，此题使用了备忘录算法的递归方式，更好的方法应该是for循环方式，如下：

- `dp[i]`表示：`[0, i)` 段绳子，即长度为`i`绳子的最大乘积（绳子至少被剪一刀）
- 状态转移方程为：`dp[i] = max{ k*dp[i-k], i*(i-k) }, 0<k<i`

## 剑指offer16 - 数值的整数次方 - 中等 - 递归

原本是一道简单的递归题，却被我弄得十分复杂。

有时候，能用递归解决的问题优先考虑递归，然后再转换成循环。

此题递归思路如下：

- 幂n为偶数时，`pow(x,n) = pow(x,n/2) * pow(x,n/2)`
- 幂n为奇数时，`pow(x,n) = pow(x,n/2) * pow(x,n/2) * x`

## 剑指offer20 - 表示数值的字符串 - 中等

编译原理的词法分析。

用正则表达式去实现，提交后一直爆出各种问题，包括时不时的编译错误。。。终于知道为何这道题的通过率这么低了。

## 剑指offer26 - 树的子结构 - 中等 - 递归

## 剑指offer29 - 顺时针打印矩阵 - 简单

参考：[leetcode题解 - 面试题29. 顺时针打印矩阵（模拟、设定边界，清晰图解）](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/)

设置上下左右边界，沿边界打印，打印完一个边界就收缩一个边界，出现边界冲突（上边界大于下边界）则终止。

## 剑指offer33 - 二叉搜索树的后序遍历序列 - 中等 - 递归+分治

二叉搜索树**左小右大**，后序遍历**左右根**。

## 剑指offer44 - 数字序列中某一位的数字 - 中等

第一种思路：设置当前下标`i`，当前数字`num`，当前数字的位数`num_count`。当`i<n`时，`num++`，若`num`的位数增加了，则`num_count++`，最后`i += num_count`。循环结束后，根据`i`和`n`的差值，就可以求出对应的数字。

第二种思路：因为`0~9`、`10~99`、`100~999`等等之间的数，位数是固定的。所以，可以直接通过**数学**方程去求解。

第一种思路的题解可能会超时，也可能不会，第二种显然更加简单快速。

## 剑指offer48 - 最长不含重复字符的子串 - 中等 - 滑动窗口

一开始，我的思路是动态规划。然而，这道题用动态规划之后的时间复杂度，似乎跟暴力破解差不多。（可能是最近动态规划学傻了。。。）

动态规划的思路想了许久，发现不对劲，于是去看[题解](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/tu-jie-hua-dong-chuang-kou-shuang-zhi-zhen-shi-xia/)。题解使用的是**滑动窗口**算法，虽然本质上是**暴力算法**的改进，但这方法实在太妙了。

## 剑指offer60 - n个骰子的点数 - 中等 - 动态规划

一定要先确定状态转移方程，如下：

`dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + dp[i-1][j-3] + dp[i-1][j-4] + dp[i-1][j-5] + dp[i-1][j-6]`

`i` 表示 i 个骰子，`j` 表示总和为 j ，`dp[i][j]` 表示 i 个骰子点数总和为 j 的事件数。状态转移方程表示：第 i 个骰子摇到 1、2、3、4、5、6 ，剩余 i-1 个骰子总和为 j-1、j-2、j-3、j-4、j-5、j-6 的事件数之和。

## 剑指offer63 - 股票的最大利润 - 中等 - 动态规划

只需要O(1)空间的动态规划。

遍历每天的股票价格，用一个变量`min`记住当天之前的股票最小值，用一个变量`max`记住股票的最大利润。如果 `当天股价 - min > max`，则使`max = 当天股价 - min`。

## 剑指offer65 - ⭐不用加减乘除做加法 - 简单 - 位运算

非常简洁的标准答案：

```c++
int add(int a, int b) {
    int sum = a^b, c; // sum = a^b 防止 b 为 0
    while (b != 0) {
        sum = a ^ b;
        c = (a & b & 0x7fffffff) << 1;
        a = sum;
        b = c;
    }
    return sum;
}
```

## 剑指offerⅡ79 - 所有子集 - 中等 - 位运算

一个长度为n的集合有2^n个子集，长度为n的集合刚好对应一个n位的0/1比特序列，每一位上，1则取集合中对应位置的数，0则不取。假设n=3，遍历000~111则对应所有的子集。

## 面试题17.11 - 单词距离 - 中等 - 双指针

对于两个递增序列A和B，若`min(A[i]-B[j])`，可用双指针：

```c++
if (A[i]>B[j]) j++;
if (A[i]<B[j]) i++;
```

## LCP5 - 发LeetCoin - 困难 - 数组储存树+双向树

用数组储存树，能达到通过下标快速索引的效果。

关键：每个结点都具有指向父结点的“指针”，每次更新结点的`coins`值，都要相对应地更新祖先结点的`coins`值。
